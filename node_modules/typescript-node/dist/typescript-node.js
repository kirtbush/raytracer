var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tsconfig = require('tsconfig');
var path_1 = require('path');
var fs_1 = require('fs');
var os_1 = require('os');
var make_error_1 = require('make-error');
var sourceMapSupport = require('source-map-support');
var extend = require('xtend');
var arrify = require('arrify');
var chalk = require('chalk');
exports.VERSION = '0.1.2';
exports.EXTENSIONS = ['.ts', '.tsx'];
function readConfig(fileName, ts) {
    var config = fileName ? tsconfig.readFileSync(fileName) : {
        files: [],
        compilerOptions: {}
    };
    config.compilerOptions = extend({
        target: 'es5'
    }, config.compilerOptions, {
        module: 'commonjs',
        sourceMap: true,
        inlineSourceMap: false,
        inlineSources: false,
        declaration: false
    });
    return ts.parseConfigFile(config, ts.sys, fileName);
}
function register(opts) {
    var cwd = process.cwd();
    var options = extend({ getFile: getFile, getVersion: getVersion }, opts);
    var files = {};
    options.compiler = options.compiler || 'typescript';
    options.ignoreWarnings = arrify(options.ignoreWarnings);
    options.configFile = options.configFile ?
        path_1.resolve(cwd, options.configFile) :
        tsconfig.resolveSync(cwd);
    var ts = require(options.compiler);
    var config = readConfig(options.configFile, ts);
    if (!options.ignoreAll && config.errors.length) {
        console.error(formatDiagnostics(config.errors, ts));
        process.exit(1);
    }
    var serviceHost = {
        getScriptFileNames: function () { return config.fileNames.concat(Object.keys(files)); },
        getScriptVersion: options.getVersion,
        getScriptSnapshot: function (fileName) {
            var contents = options.getFile(fileName);
            return contents ? ts.ScriptSnapshot.fromString(contents) : undefined;
        },
        getNewLine: function () { return os_1.EOL; },
        getCurrentDirectory: function () { return cwd; },
        getCompilationSettings: function () { return config.options; },
        getDefaultLibFileName: function (options) { return ts.getDefaultLibFilePath(config.options); }
    };
    var service = ts.createLanguageService(serviceHost);
    sourceMapSupport.install({
        retrieveFile: function (fileName) {
            if (files[fileName]) {
                return getOutput(fileName);
            }
        }
    });
    function getOutput(fileName) {
        var output = service.getEmitOutput(fileName);
        var result = output.outputFiles[1].text;
        var sourceText = service.getSourceFile(fileName).text;
        var sourceMapText = output.outputFiles[0].text;
        var sourceMapFileName = output.outputFiles[0].name;
        var sourceMap = getSourceMap(sourceMapText, fileName, sourceText);
        var base64SourceMapText = new Buffer(sourceMap).toString('base64');
        return result
            .replace('//# sourceMappingURL=' + path_1.basename(sourceMapFileName), "//# sourceMappingURL=data:application/json;base64," + base64SourceMapText);
    }
    function compile(fileName) {
        files[fileName] = true;
        var diagnostics = getDiagnostics(service, fileName, options);
        if (!options.ignoreAll && diagnostics.length) {
            var message = formatDiagnostics(diagnostics, ts);
            if (options.isEval) {
                throw new TypeScriptError(message);
            }
            console.error(message);
            process.exit(1);
        }
        return getOutput(fileName);
    }
    function loader(m, fileName) {
        return m._compile(compile(fileName), fileName);
    }
    exports.EXTENSIONS.forEach(function (extension) {
        require.extensions[extension] = loader;
    });
    return compile;
}
exports.register = register;
function getVersion(fileName) {
    return String(fs_1.statSync(fileName).mtime.getTime());
}
exports.getVersion = getVersion;
function getFile(fileName) {
    try {
        return fs_1.readFileSync(fileName, 'utf8');
    }
    catch (err) { }
}
exports.getFile = getFile;
function getDiagnostics(service, fileName, options) {
    return service.getCompilerOptionsDiagnostics()
        .concat(service.getSyntacticDiagnostics(fileName))
        .concat(service.getSemanticDiagnostics(fileName))
        .filter(function (diagnostic) {
        return options.ignoreWarnings.indexOf(String(diagnostic.code)) === -1;
    });
}
exports.getDiagnostics = getDiagnostics;
function formatDiagnostic(diagnostic, ts, cwd) {
    if (cwd === void 0) { cwd = '.'; }
    var message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
    if (diagnostic.file) {
        var path = path_1.relative(cwd, diagnostic.file.fileName);
        var _a = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start), line = _a.line, character = _a.character;
        return path + " (" + (line + 1) + "," + (character + 1) + "): " + message + " (" + diagnostic.code + ")";
    }
    return message + " (" + diagnostic.code + ")";
}
exports.formatDiagnostic = formatDiagnostic;
function formatDiagnostics(diagnostics, ts) {
    var boundary = chalk.grey('----------------------------------');
    return [
        boundary,
        chalk.red.bold('тип Unable to compile TypeScript'),
        '',
        diagnostics.map(function (d) { return formatDiagnostic(d, ts); }).join(os_1.EOL),
        boundary
    ].join(os_1.EOL);
}
function getSourceMap(map, fileName, code) {
    var sourceMap = JSON.parse(map);
    sourceMap.file = fileName;
    sourceMap.sources = [fileName];
    sourceMap.sourcesContent = [code];
    delete sourceMap.sourceRoot;
    return JSON.stringify(sourceMap);
}
exports.getSourceMap = getSourceMap;
var TypeScriptError = (function (_super) {
    __extends(TypeScriptError, _super);
    function TypeScriptError() {
        _super.apply(this, arguments);
        this.name = 'TypeScriptError';
    }
    return TypeScriptError;
})(make_error_1.BaseError);
exports.TypeScriptError = TypeScriptError;
//# sourceMappingURL=typescript-node.js.map